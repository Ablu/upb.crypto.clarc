package de.upb.crypto.clarc.acs.subpolicyproving;

import de.upb.crypto.clarc.acs.attributes.AttributeNameValuePair;
import de.upb.crypto.clarc.acs.pssignatureschnorrprotocol.PSSignatureSchnorrProtocolFactory;
import de.upb.crypto.clarc.acs.transformation.PredicateToRecreationProtocolTransformation;
import de.upb.crypto.clarc.acs.transformation.PredicateToSigmaProtocolTransformation;
import de.upb.crypto.clarc.acs.user.credentials.PSCredential;
import de.upb.crypto.clarc.acs.user.credentials.SignatureCredential;
import de.upb.crypto.clarc.predicategeneration.fixedprotocols.popk.ProofOfPartialKnowledgeProtocol;
import de.upb.crypto.clarc.predicategeneration.fixedprotocols.popk.ProofOfPartialKnowledgePublicParameters;
import de.upb.crypto.clarc.predicategeneration.policies.PredicatePolicyFact;
import de.upb.crypto.clarc.predicategeneration.policies.SigmaProtocolPolicyFact;
import de.upb.crypto.clarc.predicategeneration.policies.SubPolicyPolicyFact;
import de.upb.crypto.clarc.protocols.arguments.SigmaProtocol;
import de.upb.crypto.clarc.protocols.generalizedschnorrprotocol.GeneralizedSchnorrChallenge;
import de.upb.crypto.clarc.protocols.generalizedschnorrprotocol.GeneralizedSchnorrProtocol;
import de.upb.crypto.clarc.protocols.generalizedschnorrprotocol.GeneralizedSchnorrPublicParameter;
import de.upb.crypto.clarc.protocols.parameters.*;
import de.upb.crypto.clarc.protocols.simulator.SpecialHonestVerifierSimulator;
import de.upb.crypto.craco.commitment.pedersen.PedersenCommitmentPair;
import de.upb.crypto.craco.commitment.pedersen.PedersenCommitmentScheme;
import de.upb.crypto.craco.commitment.pedersen.PedersenCommitmentValue;
import de.upb.crypto.craco.common.RingElementPlainText;
import de.upb.crypto.craco.interfaces.policy.Policy;
import de.upb.crypto.craco.interfaces.policy.ThresholdPolicy;
import de.upb.crypto.craco.sig.ps.PSExtendedSignatureScheme;
import de.upb.crypto.craco.sig.ps.PSSignature;
import de.upb.crypto.math.serialization.Representation;
import de.upb.crypto.math.serialization.annotations.AnnotatedRepresentationUtil;
import de.upb.crypto.math.serialization.annotations.Represented;
import de.upb.crypto.math.structures.zn.Zp;

import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * The ProveCredAndPredicate protocol will randomize the signature and sends the randomized signature with the
 * announcement generated by  {@link ProofOfPartialKnowledgeProtocol}.
 * <p>
 * <p>
 * The ProveCredAndPredicate protocol can be used by prover and verifier
 * <p>
 * <p>
 * The {@link SubPolicyProvingProtocol} is a special {@link SigmaProtocol} used to prove fulfillment of a sub policy
 * (represented by a {@link SubPolicyPolicyFact}) via a single {@link PSCredential}.
 * <p>
 * It creates {@link PedersenCommitmentValue} on all {@link AttributeNameValuePair} of the {@link PSCredential} and
 * will randomize the signature and sends the randomized signature with the  announcement generated by
 * {@link ProofOfPartialKnowledgeProtocol}.
 * <p>
 * While construction the prover protocol, Pedersen commitments for the attributes of the credential are created.
 * and the credential-signature is randomized.
 * Thereby, the theoretical construction where the randomized signature and the commitments on the announcements
 * known to both can be realized.
 *
 * <ul>
 * <li>{@link SubPolicyProvingProtocol#generateAnnouncements} returns a {@link SubPolicyProvingProtocolAnnouncement}
 * containing the generated  {@link PedersenCommitmentValue} and the randomized signature, additionally the
 * announcement form bot inner protocols</li>
 * <li>{@link SubPolicyProvingProtocol#chooseChallenge} returns a randomly chosen {@link Zp.ZpElement}
 * (see {@link GeneralizedSchnorrChallenge})</li>
 * <li>{@link SubPolicyProvingProtocol#generateResponses} returns the Responses from both inner protocols </li>
 * </ul>
 */
public class SubPolicyProvingProtocol extends SigmaProtocol {

    @Represented
    private ProofOfPartialKnowledgeProtocol predicateProvingProtocol;
    @Represented
    private GeneralizedSchnorrProtocol protocolForSignature;

    public SubPolicyProvingProtocol(Representation representation) {
        AnnotatedRepresentationUtil.restoreAnnotatedRepresentation(representation, this);
    }

    /**
     * Constructor for the Prover
     * <b>Never use this externally. use {@link SubPolicyProvingProtocolFactory}</b>,
     * thus this is package private by purpose!
     * Create a prover protocol and verifier for SubPolicyProvingProtocol.
     * Only difference: are the witness values set or is only the name contained.
     *
     * @param witness          of the SubPolicyProvingProtocol protocol
     * @param publicParameters of the SubPolicyProvingProtocol and ProveCredAndPredicate protocol
     */
    SubPolicyProvingProtocol(SubPolicyProvingProtocolWitness witness,
                             SubPolicyProvingProtocolPublicParameters publicParameters) {
        // Will be set later after generating the randomized signature
        super("", publicParameters);

        // First of all, commitments on the attributes are created.
        SignatureCredential credential = witness.getCredential();
        PedersenCommitmentScheme scheme = publicParameters.getCommitmentScheme();
        List<PedersenCommitmentPair> commitmentsOnAttributes = new ArrayList<>();

        Arrays.stream(credential.getAttributes()).forEach(attr -> commitmentsOnAttributes.add(
                scheme.commit(new RingElementPlainText(attr.getZpRepresentation(publicParameters.getHashIntoZp())))));

        // Store the newly created commitments and the random values in the witness for this protocol
        witness.setCommitmentsOnAttributes(commitmentsOnAttributes);
        this.witnesses[0] = witness;
        // Store the commitment values in the public parameters.
        List<PedersenCommitmentValue> commitmentsWithoutRandoms =
                commitmentsOnAttributes.stream()
                        .map(PedersenCommitmentPair::getCommitmentValue)
                        .collect(Collectors.toList());
        ((SubPolicyProvingProtocolPublicParameters) this.getPublicParameters())
                .setCommitmentsOnAttributes(commitmentsWithoutRandoms);

        // Create a randomized signature
        Zp.ZpElement signatureRandom = witness.getSignatureRandom();
        final PSExtendedSignatureScheme psSignatureScheme = publicParameters.getPsSignatureScheme();
        PSSignature signature =
                psSignatureScheme.getSignature(witness.getCredential().getSignatureRepresentation());
        PSSignature randomizedSignature = psSignatureScheme.randomizeExistingSignature(signature, signatureRandom);

        //Update public parameters
        publicParameters.setRandomizedSignature(randomizedSignature);

        this.witnesses = new Witness[]{witness};

        //Afterwards, set up the protocol for proving the correctness of the signature
        PSSignatureSchnorrProtocolFactory factory = new PSSignatureSchnorrProtocolFactory(publicParameters);
        this.protocolForSignature = factory.getProverProtocol(witness.getCredential(),
                witness.getUsk(), witness.getNymRandom(),
                signatureRandom, witness.getCommitmentsOnAttributes());

        ThresholdPolicy transformedPolicy = transformPolicyForVerification(publicParameters.getPolicy(),
                witness, publicParameters, new AtomicInteger());
        ProofOfPartialKnowledgePublicParameters predProofPublicParameters =
                new ProofOfPartialKnowledgePublicParameters(publicParameters.getLinearSecretSharingSchemeProvider(),
                        publicParameters.getZp());
        this.predicateProvingProtocol = new ProofOfPartialKnowledgeProtocol(
                witness, predProofPublicParameters, transformedPolicy);
    }

    /**
     * Constructor for the verifier
     *
     * <b>Never use this externally. use {@link SubPolicyProvingProtocolFactory}</b>,
     * thus this is package private by purpose!
     * Create a prover protocol and verifier for SubPolicyProvingProtocol.
     * Only difference: are the witness values set or is only the name contained.
     *
     * @param nameforWitnesses                         of the SubPolicyProvingProtocol protocol-witness
     * @param subPolicyProvingProtocolPublicParameters of the SubPolicyProvingProtocol and ProveCredAndPredicate
     *                                                 protocol
     */
    SubPolicyProvingProtocol(String nameforWitnesses,
                             SubPolicyProvingProtocolPublicParameters subPolicyProvingProtocolPublicParameters) {
        super(nameforWitnesses, subPolicyProvingProtocolPublicParameters);
        // This is only a dummy. It is only used for recreation. actual protocol will be instantiated during verify
        this.protocolForSignature = new GeneralizedSchnorrProtocol(new Problem[]{new EmptyProblem()},
                null,
                GeneralizedSchnorrPublicParameter.createEmptyParameters(
                        subPolicyProvingProtocolPublicParameters.getZp()));

        ThresholdPolicy transformedPolicy =
                transformPolicyForRecreation(subPolicyProvingProtocolPublicParameters.getPolicy(),
                        subPolicyProvingProtocolPublicParameters, new AtomicInteger());
        ProofOfPartialKnowledgePublicParameters predProofPublicParameters =
                new ProofOfPartialKnowledgePublicParameters(subPolicyProvingProtocolPublicParameters
                        .getLinearSecretSharingSchemeProvider(),
                        subPolicyProvingProtocolPublicParameters.getZp());
        this.predicateProvingProtocol =
                new ProofOfPartialKnowledgeProtocol(predProofPublicParameters, transformedPolicy);
    }

    /**
     * Constructor for simulation.
     * This is basically a verifier constructor, with the difference that all publicly known values are set
     * before the verify-method is called (since they are known and do not need to be extracted form the announcement)
     *
     * @param witness  empty witness with unique name of the protocol
     * @param subPolPP of the SubPolicyProvingProtocol and ProveCredAndPredicate protocol
     */
    SubPolicyProvingProtocol(EmptyWitness witness, SubPolicyProvingProtocolPublicParameters subPolPP) {

        // Will be set later after generating the randomized signature
        super(new Witness[]{witness}, subPolPP);

        // First of all, create a randomized signature
        Zp.ZpElement signatureRandom = subPolPP.getZp().getUniformlyRandomElement();
        final PSExtendedSignatureScheme psSignatureScheme = subPolPP.getPsSignatureScheme();
        PSSignature randomizedSignature = subPolPP.getRandomizedSignature();

        // Since the simulator has generated all neccessary parameter, no update of the pp is needed

        // Afterwards, set up the protocol for proving the correctness of the signature
        PSSignatureSchnorrProtocolFactory factory = new PSSignatureSchnorrProtocolFactory(subPolPP);
        this.protocolForSignature = factory.getVerifierProtocol();
        ThresholdPolicy transformedPolicy =
                transformPolicyForVerification(subPolPP.getPolicy(), witness, subPolPP, new AtomicInteger());
        ProofOfPartialKnowledgePublicParameters poPKPublicParameters = new ProofOfPartialKnowledgePublicParameters(
                subPolPP.getLinearSecretSharingSchemeProvider(), subPolPP.getZp());
        this.predicateProvingProtocol =
                new ProofOfPartialKnowledgeProtocol(witness, poPKPublicParameters, transformedPolicy);
    }

    /**
     * Traverse and copy the given {@link ThresholdPolicy} whereby all leaves ({@link PredicatePolicyFact}) will be
     * transformed to {@link SigmaProtocolPolicyFact}.
     *
     * @param policy      {@link ThresholdPolicy} which leaves  are {@link PredicatePolicyFact} to
     *                    createProtocolForSubpolicy
     * @param witness     {@link Witness} to be used during transformation
     * @param subPolPP    public parameters of the enclosing protocol
     * @param leafCounter counter to determine unique index for each visited leaf
     * @return {@link ThresholdPolicy} which leaves are {@link SigmaProtocolPolicyFact}
     */
    private ThresholdPolicy transformPolicyForVerification(ThresholdPolicy policy, Witness witness,
                                                           SubPolicyProvingProtocolPublicParameters subPolPP,
                                                           AtomicInteger leafCounter) {
        List<Policy> children = policy.getChildren();
        List<Policy> transformedChildren = new ArrayList<>(children.size());
        for (Policy childPolicy : children) {
            if (childPolicy instanceof PredicatePolicyFact) {
                int leafId = leafCounter.getAndIncrement();
                SigmaProtocol protocol =
                        PredicateToSigmaProtocolTransformation.transform((PredicatePolicyFact) childPolicy,
                                witness, subPolPP, leafId);
                SigmaProtocolPolicyFact leaf = new SigmaProtocolPolicyFact(protocol, leafId);
                transformedChildren.add(leaf);
            } else if (childPolicy instanceof ThresholdPolicy) {
                transformedChildren
                        .add(transformPolicyForVerification((ThresholdPolicy) childPolicy, witness, subPolPP,
                                leafCounter));
            } else {
                throw new IllegalArgumentException("Malformed Policy!");
            }
        }
        return new ThresholdPolicy(policy.getThreshold(), transformedChildren);
    }

    /**
     * Traverse and copy the given {@link ThresholdPolicy} whereby all leaves ({@link PredicatePolicyFact}) will be
     * transformed to {@link SigmaProtocolPolicyFact}. Those resulting protocols are "empty" in that sense
     * that they can indeed successfully reconstruct their respective {@link Announcement}, {@link Challenge} and
     * {@link Response} objects, but can not actually execute the protocol.
     *
     * @param policy      {@link ThresholdPolicy} which leaves  are {@link PredicatePolicyFact} to
     *                    createProtocolForSubpolicy
     * @param subPolPP    public parameters of the enclosing protocol
     * @param leafCounter counter to determine unique index for each visited leaf
     * @return {@link ThresholdPolicy} which leaves are "empty" {@link SigmaProtocolPolicyFact} only to be used
     * for recreation.
     */
    private ThresholdPolicy transformPolicyForRecreation(ThresholdPolicy policy,
                                                         SubPolicyProvingProtocolPublicParameters subPolPP,
                                                         AtomicInteger leafCounter) {
        List<Policy> children = policy.getChildren();
        List<Policy> transformedChildren = new ArrayList<>(children.size());
        for (Policy childPolicy : children) {
            if (childPolicy instanceof PredicatePolicyFact) {
                int leafId = leafCounter.getAndIncrement();
                SigmaProtocol protocol = PredicateToRecreationProtocolTransformation.transform(
                        (PredicatePolicyFact) childPolicy, subPolPP, leafId);
                transformedChildren.add(new SigmaProtocolPolicyFact(protocol, leafId));
            } else if (childPolicy instanceof ThresholdPolicy) {
                transformedChildren
                        .add(transformPolicyForRecreation((ThresholdPolicy) childPolicy, subPolPP, leafCounter));
            } else {
                throw new IllegalArgumentException("Malformed Policy!");
            }
        }
        return new ThresholdPolicy(policy.getThreshold(), transformedChildren);
    }

    @Override
    public SubPolicyProvingProtocol setWitnesses(List<Witness> witnesses) {
        this.predicateProvingProtocol = this.predicateProvingProtocol.setWitnesses(witnesses);
        this.protocolForSignature = protocolForSignature.setWitnesses(witnesses);
        List<SubPolicyProvingProtocolWitness> filteredList =
                witnesses.stream().filter(witness -> witness instanceof SubPolicyProvingProtocolWitness)
                        .map(witness -> (SubPolicyProvingProtocolWitness) witness)
                        .filter(witness -> witness.getName().equals(this.witnesses[0].getName()))
                        .collect(Collectors.toList());
        if (filteredList.size() > 1) {
            throw new IllegalArgumentException("The given list of witnesses contains more than one matching witness " +
                    "for the P1 Protocol");
        } else if (filteredList.size() == 1) {
            this.witnesses[0] = filteredList.get(0);
        }
        return this;

    }

    @Override
    public boolean isFulfilled() {
        if (this.protocolForSignature == null || this.predicateProvingProtocol == null) {
            return false;
        } else {
            return protocolForSignature.isFulfilled() && predicateProvingProtocol.isFulfilled();
        }
    }

    @Override
    public Announcement[] generateAnnouncements() {
        SubPolicyProvingProtocolPublicParameters subPolicyPP =
                (SubPolicyProvingProtocolPublicParameters) this.publicParameters;
        return new Announcement[]{new SubPolicyProvingProtocolAnnouncement(
                ((SubPolicyProvingProtocolPublicParameters) this.publicParameters).getRandomizedSignature(),
                subPolicyPP.getCommitmentsOnAttributes(),
                subPolicyPP.getDisclosedElements(),
                predicateProvingProtocol.generateAnnouncements(),
                this.protocolForSignature.generateAnnouncements())};
    }

    @Override
    public Challenge chooseChallenge() {
        return new GeneralizedSchnorrChallenge(
                ((SubPolicyProvingProtocolPublicParameters) publicParameters).getZp().getUniformlyRandomElement());
    }

    @Override
    public Challenge createChallengeFromByteArray(byte[] integer) {
        BigInteger representedChallenge = new BigInteger(integer);
        return new GeneralizedSchnorrChallenge(((SubPolicyProvingProtocolPublicParameters) this.publicParameters)
                .getZp().createZnElement(representedChallenge));
    }

    @Override
    public Response[] generateResponses(Challenge challenge) {
        // The secret is shared. Since an and is required, it can easily be forwarded to both protocols.
        return new Response[]{new SubPolicyProvingProtocolResponse(this.protocolForSignature
                .generateResponses(challenge), this.predicateProvingProtocol.generateResponses(challenge))};
    }

    @Override
    public boolean verify(Announcement[] announcements, Challenge challenge, Response[] responses) {
        if (announcements == null || announcements.length != 1 || Arrays.stream(announcements)
                .anyMatch(announcement -> !(announcement
                        instanceof
                        SubPolicyProvingProtocolAnnouncement)
                )) {
            throw new IllegalArgumentException("The given Announcements are not valid");
        }
        if (!(challenge instanceof GeneralizedSchnorrChallenge)) {
            throw new IllegalArgumentException("The given Challenge is not valid");
        }
        if (responses == null || responses.length != 1 ||
                Arrays.stream(responses)
                        .anyMatch(response -> !(response instanceof SubPolicyProvingProtocolResponse))) {
            throw new IllegalArgumentException("The given Responses are not valid");
        }


        //Extract all needed messages
        SubPolicyProvingProtocolAnnouncement subPolicyProvingProtocolAnnouncement =
                (SubPolicyProvingProtocolAnnouncement) announcements[0];
        Response[] responsesPSSignatureSchnorrProtocol = ((SubPolicyProvingProtocolResponse) responses[0])
                .getResponsesPSSignatureSchnorrProtocol();
        Response[] responsesP2Protocol = ((SubPolicyProvingProtocolResponse) responses[0]).getResponsesPoPKProtocol();
        SubPolicyProvingProtocolPublicParameters subPolPP =
                (SubPolicyProvingProtocolPublicParameters) this.publicParameters;

        //set randomized signature created by the prover and send in the announcement
        subPolPP.setRandomizedSignature(subPolicyProvingProtocolAnnouncement.getRandomizedSignature());
        subPolPP.setCommitmentsOnAttributes(subPolicyProvingProtocolAnnouncement.getCommitmentsOnAttributes());
        subPolPP.setDisclosedElements(subPolicyProvingProtocolAnnouncement.getDisclosedElements());

        PSSignatureSchnorrProtocolFactory factory = new PSSignatureSchnorrProtocolFactory(subPolPP);

        ThresholdPolicy transformedPolicy =
                transformPolicyForVerification(subPolPP.getPolicy(), new EmptyWitness(), subPolPP, new AtomicInteger());

        //Recreate P2Protocol and PSSignatureSchnorrProtocol
        ProofOfPartialKnowledgePublicParameters poPKPublicParameters = new ProofOfPartialKnowledgePublicParameters(
                subPolPP.getLinearSecretSharingSchemeProvider(), subPolPP.getZp());
        ProofOfPartialKnowledgeProtocol poPKProtocol =
                new ProofOfPartialKnowledgeProtocol(poPKPublicParameters, transformedPolicy);
        GeneralizedSchnorrProtocol psSignatureSchnorrProtocol = factory.getVerifierProtocol();

        boolean p2Verified =
                poPKProtocol.verify(subPolicyProvingProtocolAnnouncement.getAnnouncementsOfPredicateProvingProtocol(),
                        challenge, responsesP2Protocol);
        boolean pSSignatureSchnorrProtocolVerified =
                psSignatureSchnorrProtocol.verify(subPolicyProvingProtocolAnnouncement
                        .getAnnouncementsOfSignatureProtocol(), challenge, responsesPSSignatureSchnorrProtocol);

        return p2Verified && pSSignatureSchnorrProtocolVerified;
    }

    @Override
    public Announcement recreateAnnouncement(Representation representation) {
        return new SubPolicyProvingProtocolAnnouncement(representation, this.protocolForSignature,
                this.predicateProvingProtocol,
                ((SubPolicyProvingProtocolPublicParameters) this.publicParameters).getPsSignatureScheme());
    }

    @Override
    public Challenge recreateChallenge(Representation representation) {
        return this.protocolForSignature.recreateChallenge(representation);
    }

    @Override
    public Response recreateResponse(Representation representation) {
        return new SubPolicyProvingProtocolResponse(representation, protocolForSignature, predicateProvingProtocol);
    }

    public ProofOfPartialKnowledgeProtocol getPredicateProvingProtocol() {
        return predicateProvingProtocol;
    }

    public GeneralizedSchnorrProtocol getProtocolForSignature() {
        return protocolForSignature;
    }

    @Override
    public Representation getRepresentation() {
        return AnnotatedRepresentationUtil.putAnnotatedRepresentation(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SubPolicyProvingProtocol that = (SubPolicyProvingProtocol) o;
        return Objects.equals(predicateProvingProtocol, that.predicateProvingProtocol) &&
                Objects.equals(protocolForSignature, that.protocolForSignature);
    }

    @Override
    public int hashCode() {
        return Objects.hash(predicateProvingProtocol, protocolForSignature);
    }

    public static String getNameForWitnesses(ThresholdPolicy policy) {
        return "ProveCredAndPredicate_" + Base64.getEncoder().encodeToString(policy.getUniqueByteRepresentation());
    }

    @Override
    public SpecialHonestVerifierSimulator getSimulator() {
        return new SubPolicyProvingProtocolSimulator(this);
    }
}
