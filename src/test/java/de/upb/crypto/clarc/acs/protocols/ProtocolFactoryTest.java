package de.upb.crypto.clarc.acs.protocols;

import de.upb.crypto.clarc.acs.attributes.AttributeNameValuePair;
import de.upb.crypto.clarc.acs.attributes.AttributeSpace;
import de.upb.crypto.clarc.acs.issuer.credentials.CredentialIssuerPublicIdentity;
import de.upb.crypto.clarc.acs.protocols.impl.clarc.provecred.*;
import de.upb.crypto.clarc.predicategeneration.fixedprotocols.popk.ProofOfPartialKnowledgeProtocol;
import de.upb.crypto.clarc.protocols.InteractiveThreeWayAoKTester;
import de.upb.crypto.clarc.protocols.arguments.SigmaProtocol;
import de.upb.crypto.clarc.protocols.parameters.Announcement;
import de.upb.crypto.clarc.protocols.parameters.Challenge;
import de.upb.crypto.clarc.protocols.parameters.Response;
import de.upb.crypto.math.serialization.Representation;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;

import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * This class provides test cases for the {@link ProofOfPartialKnowledgeProtocol} generated by
 * {@link ProverProtocolFactory} and
 * {@link VerifierProtocolFactory}.
 */
public class ProtocolFactoryTest {

    /**
     * This test checks that all protocols of the given {@link ProtocolFactoryExecutionContext} return their correct
     * {@link SigmaProtocol#isFulfilled} status.
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    public void testFulfillmentRequirements(ProtocolFactoryExecutionContext context) {
        testProtocolFulfillment(context);
    }

    private void testProtocolFulfillment(ProtocolFactoryExecutionContext context) {
        if (context.fulfillingProtocolProver instanceof SigmaProtocol) {
            assertTrue(context.fulfillingProtocolProver.isFulfilled(),
                    "The prover protocol which possesses a fulfilling credential must be fulfilled");
        }
        if (context.anotherFulfillingProtocolProver instanceof SigmaProtocol) {
            assertTrue(context.anotherFulfillingProtocolProver.isFulfilled(),
                    "The prover protocol which possesses a fulfilling credential must be fulfilled");
        }
        if (context.nonFulfillingProtocolProver instanceof SigmaProtocol) {
            assertFalse(context.nonFulfillingProtocolProver.isFulfilled(),
                    "The prover protocol without a fulfilling credential must not be fulfilled.");
        }
        if (context.protocolVerifier instanceof SigmaProtocol) {
            assertFalse(context.protocolVerifier.isFulfilled(),
                    "The verifier protocol must not be fulfilled.");
        }
    }

    /**
     * This test checks that all protocols of the given {@link ProtocolFactoryWithMasterCredExecutionContext}
     * return their correct {@link SigmaProtocol#isFulfilled} status.
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void testFulfillmentRequirementsForMasterCred(ProtocolFactoryWithMasterCredExecutionContext context) {
        testProtocolFulfillment(context);
        if (context.invalidMasterCredProtocolProver instanceof SigmaProtocol) {
            assertFalse(context.invalidMasterCredProtocolProver.isFulfilled(),
                    "The prover protocol without a valid master credential must not be fulfilled.");
        }
        if (context.invalidMasterCredProtocolVerifier instanceof SigmaProtocol) {
            assertFalse(context.invalidMasterCredProtocolVerifier.isFulfilled(),
                    "The verifier protocol must not be fulfilled.");
        }
    }

    /**
     * Positive test checking that for a correct protocol execution the verifier accepts.
     * <p>
     * see {@link InteractiveThreeWayAoKTester#protocolExecutionInternalRandomnessTest}
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void testFulfillingProtocolExecution(ProtocolFactoryExecutionContext context) {
        InteractiveThreeWayAoKTester
                .protocolExecutionInternalRandomnessTest(context.fulfillingProtocolProver, context.protocolVerifier);

        if (context.protocolVerifier instanceof SigmaProtocolWithDisclosure
                && context.selectiveDisclosures != null) {
            SigmaProtocolWithDisclosure disclosureVerifier = (SigmaProtocolWithDisclosure) context.protocolVerifier;


            // Collect all disclosed attributes by IssuerPublicKey to account for multiple sub policies
            // from the same issuer
            Map<Representation, Set<AttributeNameValuePair>> map = new HashMap<>();
            Map<Representation, Set<Integer>> integerMap = new HashMap<>();

            List<SelectiveDisclosure> requiredDisclosures = Arrays.stream(context.selectiveDisclosures)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

            for (SelectiveDisclosure disclosure : requiredDisclosures) {
                Representation issuerPublicKey = disclosure.getIssuerPublicKey();
                Set<AttributeNameValuePair> attributeList = map.computeIfAbsent(issuerPublicKey, key -> new HashSet<>());
                Set<Integer> indexList = integerMap.computeIfAbsent(issuerPublicKey, key -> new HashSet<>());

                indexList.addAll(disclosure.getAttributeIndices());

                disclosureVerifier.getDisclosedAttributes().stream()
                        .filter(attr -> attr.getIssuerPublicKey().equals(issuerPublicKey))
                        .map(DisclosedAttributes::getAttributes)
                        .forEach(attributeList::addAll);

            }

            // Verify that for each issuer the required disclosures match the disclosed elements
            for (Map.Entry<Representation, Set<Integer>> entry : integerMap.entrySet()) {
                AttributeSpace space =
                        context.issuerPublicIdentities
                                .stream()
                                .filter(identity -> identity.getIssuerPublicKey().equals(entry.getKey()))
                                .map(CredentialIssuerPublicIdentity::getAttributeSpace)
                                .findFirst().get();

                List<Integer> disclosedIndices = map.get(entry.getKey()).stream()
                        .map(space::getAttributeIndex)
                        .collect(Collectors.toList());

                assertTrue(disclosedIndices.containsAll(entry.getValue()), "Mismatch between disclosed" +
                        " and required attributes.");
            }
        }
    }

    /**
     * This negative test checks cases where the verify method is called with not matching parameters and therefore
     * should return false.
     * <p>
     * see {@link InteractiveThreeWayAoKTester#protocolExecutionInternalRandomnessNegativeTest}
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void testNonMatchingParameterProtocolExecution(ProtocolFactoryExecutionContext context) {
        InteractiveThreeWayAoKTester.protocolExecutionInternalRandomnessNegativeTest(context.fulfillingProtocolProver,
                context.anotherFulfillingProtocolProver, context.protocolVerifier);
    }

    /**
     * This negative test checks cases where the verify method is called with not matching parameters and therefore
     * should return false.
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void testNonFulfillingProtocolExecution(ProtocolFactoryExecutionContext context) {
        Announcement[] announcements = context.nonFulfillingProtocolProver.generateAnnouncements();
        Challenge challenge = context.protocolVerifier.chooseChallenge();
        Response[] responses = context.nonFulfillingProtocolProver.generateResponses(challenge);

        assertFalse(context.protocolVerifier.verify(announcements, challenge, responses), "For a non-fulfilling" +
                "prover the verifier must not accept.");
    }

    /**
     * This negative test checks cases where the verify method is called without a valid master credential
     * and therefore should return false.
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void testInvalidMasterCredProtocolExecution(ProtocolFactoryWithMasterCredExecutionContext context) {
        Announcement[] announcements = context.invalidMasterCredProtocolProver.generateAnnouncements();
        Challenge challenge = context.invalidMasterCredProtocolVerifier.chooseChallenge();
        Response[] responses = context.invalidMasterCredProtocolProver.generateResponses(challenge);

        assertFalse(context.invalidMasterCredProtocolVerifier.verify(announcements, challenge, responses),
                "For a prover without valid master credential the verifier must not accept.");
    }

    /**
     * This tests checks whether the {@link ProtocolFactoryExecutionContext#fulfillingProtocolProver} and
     * {@link ProtocolFactoryExecutionContext#protocolVerifier} can also properly be executed, once they have been
     * serialised
     * and deserialized.
     * <p>
     * see {@link InteractiveThreeWayAoKTester#representationForProtocolExecutionTest}
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void representationForProtocolExecutionTest(ProtocolFactoryExecutionContext context) {
        InteractiveThreeWayAoKTester.representationForProtocolExecutionTest(context.fulfillingProtocolProver,
                context.protocolVerifier);
    }

    /**
     * This tests checks whether the {@link ProtocolFactoryExecutionContext#fulfillingProtocolProver} and
     * {@link ProtocolFactoryExecutionContext#protocolVerifier} can also properly be executed, once their messages have
     * been serialized and deserialized.
     * <p>
     * see {@link InteractiveThreeWayAoKTester#recreateTest}
     *
     * @param context this test's execution context
     */
    @TestTemplate
    @ExtendWith(ProtocolFactoryExecutionContextProvider.class)
    @ExtendWith(ProtocolFactoryWithMasterCredExecutionContextProvider.class)
    public void recreateTest(ProtocolFactoryExecutionContext context) {
        InteractiveThreeWayAoKTester.recreateTest(context.fulfillingProtocolProver, context.protocolVerifier);
    }

}
